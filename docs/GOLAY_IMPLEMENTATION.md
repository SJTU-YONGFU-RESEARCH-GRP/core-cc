# Golay Error Correction Code Implementation

This document describes the Golay Error Correction Code implementation in both Python and Verilog.

## Overview

Golay codes are one of the most important error-correcting codes, discovered by Marcel J. Golay in 1949. The binary Golay code is a (23,12) perfect code that can correct up to 3 errors and detect up to 7 errors. It's widely used in deep space communications and magnetic storage systems.

## Supported Configurations

The implementation uses the binary (23,12) Golay code:

| Parameter | Value | Description |
|-----------|-------|-------------|
| Codeword Length (n) | 23 bits | Total codeword size |
| Data Bits (k) | 12 bits | Information bits |
| Parity Bits (m) | 11 bits | Redundancy bits |
| Minimum Distance (d) | 7 | Can correct 3 errors |
| Code Rate | 12/23 ≈ 52% | Information efficiency |

## Python Implementation

### Location: `src/golay_ecc.py`

The Python implementation provides:

- **GolayECC**: Main Golay ECC class
- **GolayCode**: Core (23,12) Golay code implementation
- **Syndrome Decoding**: Error correction using syndrome lookup
- **Generator Polynomial**: x¹¹ + x⁹ + x⁷ + x⁶ + x⁵ + x + 1

### Key Features

1. **Perfect Code**: Optimal error correction for given parameters
2. **Syndrome Decoding**: Efficient error location and correction
3. **Mathematical Accuracy**: Implements true Golay code mathematics
4. **Educational Value**: Clear implementation of coding theory concepts

### Usage Example

```python
from src.golay_ecc import GolayECC

# Create Golay ECC for 12-bit data blocks
golay = GolayECC()

# Encode 12-bit data into 23-bit codeword
data = 0b101101001010
codeword = golay.encode(data)

# Decode with automatic error correction (up to 3 errors)
decoded_data, error_type = golay.decode(codeword)

# Access the underlying Golay code
golay_code = golay.golay_code
encoded_bits = golay_code.encode([1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0])
```

## Verilog Implementation

### Module Structure

The Verilog implementation consists of:

1. **golay_ecc.v**: Main Golay ECC module with hardware syndrome decoder

### Key Features

1. **Syndrome Table**: Pre-computed syndrome lookup for error correction
2. **Parallel Processing**: Efficient combinational logic
3. **Real-time Correction**: Single-cycle error correction
4. **Resource Optimized**: Balanced performance and area

### Module Interface

```verilog
module golay_ecc (
    input  wire        clk,
    input  wire        rst_n,
    input  wire        encode_en,
    input  wire        decode_en,
    input  wire [11:0] data_in,
    input  wire [22:0] codeword_in,
    output reg  [22:0] codeword_out,
    output reg  [11:0] data_out,
    output reg         error_detected,
    output reg         error_corrected,
    output reg         valid_out
);
```

## Testbenches

### Available Testbenches

1. **golay_ecc_tb.c**: C testbench for hardware verification
2. **test_golay_ecc.py**: Python unit tests for Golay code functionality

### Test Coverage

- **Encoding Verification**: Tests correct codeword generation
- **Error Correction**: Tests 1, 2, and 3-bit error correction
- **Error Detection**: Tests detection beyond correction capability
- **Syndrome Decoding**: Validates syndrome computation and lookup

## Mathematical Background

### Generator Polynomial

The Golay code uses the generator polynomial:

```
g(x) = x¹¹ + x⁹ + x⁷ + x⁶ + x⁵ + x + 1
```

### Code Construction

The (23,12) Golay code can be constructed as:

1. **Systematic Form**: [I₁₂ | P₁₁] where P is the parity matrix
2. **Cyclic Code**: Generated by the polynomial above
3. **Perfect Code**: Sphere packing bound is achieved

### Syndrome Decoding

For error correction:

```
Received vector: r = c + e (where e has weight ≤ 3)
Syndrome: s = r × H^T
Error pattern: e = syndrome_lookup(s)
Corrected: ĉ = r + e
```

## Performance Characteristics

### Error Correction Capability

- **Single Errors**: 100% correction
- **Double Errors**: 100% correction
- **Triple Errors**: 100% correction
- **Detection**: Up to 7 errors can be detected

### Code Rate

- **12/23 ≈ 52%**: Good efficiency for strong error correction
- **Fixed Rate**: No rate adaptation
- **Overhead**: 11 parity bits for 12 data bits

### Hardware Complexity

- **Encoding**: O(n×k) operations
- **Decoding**: O(n) syndrome + O(1) lookup
- **Memory**: Syndrome lookup table (2¹¹ entries)

## Usage Guidelines

### Choosing Golay Configurations

1. **Deep Space**: Excellent for space communications
2. **Magnetic Storage**: Good for disk/tape storage
3. **Wireless Channels**: Effective in high-noise environments
4. **Short Messages**: Ideal for 12-bit data blocks

### Implementation Considerations

1. **Block Size**: Fixed 12-bit data blocks
2. **Latency**: Single-block processing
3. **Memory Usage**: Syndrome table requires storage
4. **Performance**: Excellent for short data blocks

## Comparison with Other ECCs

| ECC Type | Data Bits | Total Bits | Correction | Detection | Rate |
|----------|-----------|------------|------------|-----------|------|
| Hamming (7,4) | 4 | 7 | 1 error | 2 errors | 57% |
| BCH (15,7) | 7 | 15 | 2 errors | 4 errors | 47% |
| Golay (23,12) | 12 | 23 | 3 errors | 7 errors | 52% |
| Reed-Solomon | Variable | Variable | Multiple | Multiple | Variable |

## Advantages of Golay Codes

1. **Perfect Code**: Achieves theoretical optimum
2. **Strong Correction**: Corrects up to 3 errors
3. **Simple Decoding**: Syndrome lookup table
4. **Well-Studied**: Extensive mathematical analysis

## Historical Significance

Golay codes were discovered in 1949 and have been used in:

- **Voyager Spacecraft**: Deep space communications
- **CD-ROM**: Data storage error correction
- **Wireless Standards**: Various communication protocols
- **Research**: Foundation for modern coding theory

## Future Enhancements

1. **Extended Golay**: (24,12) extended Golay code
2. **Ternary Golay**: Non-binary Golay codes
3. **Soft Decoding**: Improved performance with soft inputs
4. **Hardware Optimization**: Further area and speed improvements

## References

1. Golay, M. J. E. (1949). Notes on digital coding. Proceedings of the IRE, 37(6), 657.
2. MacWilliams, F. J., & Sloane, N. J. A. (1977). The theory of error-correcting codes. North-Holland.
3. Lin, S., & Costello, D. J. (2004). Error control coding: fundamentals and applications. Pearson Education.
